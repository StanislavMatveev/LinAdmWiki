# Диагностика железа на Linux системах

*[[linux|<- Назад]]*

*[[index|<- На главную]]*
***
## Диагностика с помощью top

### Общая информация

`top` - утилита Linux которая используется для отображения *системной информации* о процессах, работающих в данный момент. Так же можно посмотреть загрузку процессора, памяти и других системных ресурсов.

*Некоторые важные команды:*

- `q` - выход;
- `<` или `>` - выбирает параметр по которому будет осуществляться сортировка;
- `P` - сортирует процессы по использованию процессора;
- `M` - сортирует процессы по использованию памяти;
- `u` - оставляет процессы только для определенного пользователя;
- `k` - убивает выбранный процесс;
- `A` - переход в "многооконный" режим;
- `m` - изменяет тип отображения оперативной памяти (внешний вид);
- `1` - изменяет тип отображения CPU каждый процессор отдельно или все вместе;
- `t` - изменяет тип отображения CPU (внешний вид);
- `a` - перемещение по окнам;
- `z` - "окрашивает" интерфейс;
- `Z` - включает режим настройки "окрашивания";
- `x` - выделяет по какому параметру отсортированы процессы;
- `W` - сохраняет настроенную конфигурацию в файл `~/.toprc` или `~/config/procpc/.toprc`;
- `h` - выводит справку по командам.

*Сведения о процессах:*

- `PID` - идентификатор процесса;
- `USER` - пользователь, запустивший процесс;
- `PR` - приоритет процесса;
- `NI` - измененный приоритет (присвоенный пользователем с помощью команды nice);
- `VIRT` - объем используемой виртуальной памяти (здесь выводится тот объем памяти, который был запрошен процессом, даже если фактически используется меньше);
- `RES` - объем используемой оперативной памяти (в данном случае, если процесс запросил 50Мб памяти, а использует 10Мб, будет выведено 10Мб);
- `SHR` - объем памяти, разделяемой с другими процессами (т.е.  память, которая может быть использована другими процессами);
- `S` - статус процесса;
- `%CPU` - процент использования процессорного времени;
- `%MEM` - процент использования оперативной памяти;
- `TIME` - общее время работы процесса;
- `COMMAND` - имя процесса (команда, которой был запущен процесс).

### Показатели CPU

**Справочная информация**

У CPU могут быть следующие *основные* состояния:

- *idle* (простой процессора), когда ничего не происходит;
- запуск процессов в *userspace* (пространство пользователя - программы и пр.);
- запуск процессов в *kernelspace* (пространство ядра - процессы, запуск которых инициирован ядром).

> *Дополнительно* эти три состояния могут быть разделены по *приоритету*, так называемый *nice*. *По умолчанию*, все процессы запущенны с равным приоритетом 0. *Nice* принимает значения от -20 до 19.

**Разбор показателей CPU top**

```top
%Cpu(s):  0,3 us,  0,3 sy,  0,0 ni, 99,3 id,  0,0 wa,  0,0 hi,  0,0 si,  0,0 st
```

- `0,3 us` - информирует о том, что CPU тратит всего 0,3% своего времени на выполнение процессов в *userspace*. Это может быть любой процесс, которые *не принадлежит ядру* и выполняется в *пользовательском пространстве* (веб-сервер, БД, компилятор и т.д.). Обычно на нагруженном сервере *большую* часть занимает именно данный показатель.
- `0,3 sy` - это количество времени (в процентах), которое процессор потратил на *запуск ядра*. Все процессы и системные ресурсы *обрабатываются* ядром. Когда процессу *пользовательского пространства* нужно что-то из системы (выделить память, выполнить операции ввода-вывода, создать дочерний процесс и т.д.), то в игру вступает ядро. Данный показатель *должен быть* как можно *меньше* при штатной работе сервера.
- `0,0 ni` - данный показатель выводит данные процессов, которые *использовали процессорное время* и приоритет которых был *изменен* с помощью *nice*. В данном случае все по нулям, т.к. никаким процессам доп.приоритет не выдавался.
- `99,3 id` - *idle time*, о котором говорилось выше, 99,3% времени CPU простаивал.
- `0,0 wa` - статистика по операциям *ввода-вывода*, такие как чтение или запись на диск. 

> Есть моменты, когда *CPU* запускает такие операции и ему приходится *ждать* их завершения, т.к. *скорость* работы дисковых накопителей намного *меньше*, чем скорость работы CPU.

- `0,0 hi & 0,0 si` - эти две статистики показывают, сколько времени (в процентах) процессор потратил на *обслуживание прерываний*. `hi` - *аппаратные*, отправляемые к CPU с различных *периферийных* устройств, например, с дисков или сетевых интерфейсов. `si` - *программные*, которые происходят на уровне ядра.
- `0,0 st` - относится только к *виртуальным машинам* (ВМ). Когда Linux запущен как ВМ на гипервизоре, `st` показывает сколько времени его vCPU провел в *ожидании обслуживания* гипервизором другого vCPU, работающего на другой ВМ. Поскольку обычно эти *виртуальные процессоры* совместно используют один и тот же *физический процессор* (или процессоры), то будут моменты, когда виртуальная машина хотела выполнить какое-либо действие, но гипервизор вместо этого назначал ресурсы CPU другой виртуальной машине.

[[linux_diagnistics#linux|^ В начало]]
***
## Диагностика с помощью atop

`atop` - это утилита для *мониторинга* системных ресурсов в Linux. Более *продвинутый* аналог `top`, основным *отличием* является функция *ведения логов*, благодаря чему, есть возможность отслеживать работу процессов за прошедшие дни.
Утилита способна отображать *конфиденциальную* информацию о системе, которую можно получить с помощью `sudo`.

При запуске, экран разделен на две панели, сверху - накопленная *статистика* использования ресурсов системы, снизу - *информация* для каждого процесса.

**Накопленная статистика использования ресурсов системы**
![[atop_panel.png]]

- `PRC` - процессы
- `CPU` - нагрузка CPU
- `cpu` - нагрузка CPU для каждого ядра
- `CPL` - нагрузка процессора
- `MEM` - использование оперативной памяти
- `SWP` - подкачка оперативной памяти
- `DSK` - использование диска
- `NET` - сетевая статистика

**Информация для каждого процесса**

- `PID` - идентификатор процесса
- `SYSCPU` - количество процессорного времени, затраченного при обработке системных задач
- `USRCPU` - количество процессорного времени, затраченного в режиме пользователя
- `VGROW` - объем виртуальной памяти, занятой процессом с момента последнего обновления значений
- `RGROW` - объем физической памяти, занятой процессом с момента последнего обновления значений
- `RDDSK` - размер переданных данных при чтении с диска
- `WRDSK` - размер переданных данных при записи на диск
- `RUID` - реальный идентификатор пользователя, от имени которого выполняется процесс
- `EUID` - эффективный идентификатор пользователя, под которым выполняется процесс
- `ST` - текущий статус процесса
- `EXC` - код завершения после окончания процесса
- `THR` - количество потоков внутри процесса
- `S` - текущий статус основного потока процесса
- `CPU` - процент использования CPU всеми процессами
- `CMD` - название процесса

**Дополнительные варианты запуска atop**

- Вывод информации по логу за сегодня

```bash
atop -r
```

- Посмотреть информацию по логу за конкретный день

```bash
atop -r /var/log/atop/atop_20241231
```

> Чтобы регулярно велись логи, необходимо добавить процесс в автозагрузку с помощью `systemctl`.

- Вывод информации по использованию памяти

```bash
atop -m
```

- Вывод информации по дискам

```bash
atop -d
```

- Поиск запущенных в фоновом режиме команд

```bash
atop -c
```

- Информация о потоках

```bash
atop -y
```

- Поиск времени запуска процесса

```bash
atop -v
```

- Количество процессов для каждого пользователя в системе

```bash
atop -au
```

- Информация на каком ядре работает процесс

```bash
atop -s
```

> Все эти режимы можно включить из основного режима, просто нажав соответствующую клавишу.

[[linux_diagnistics#linux|^ В начало]]
***
## Дополнительные утилиты для диагностики

`fio` (Flexible I/O Tester) - это утилита для тестирования *производительности* ввода/вывода (I/O) на Linux. Она позволяет создавать различные тестовые *сценарии* для оценки производительности дисков, файловых систем и других устройств хранения данных.

```bash
fio --name=lineread --ioengine=libaio --rw=read --direct=1 --size=1G --directory=/tmp/fio/
```
*где:*

- `name` - название теста
- `ioengine` - библиотека для тестирования (наилучшая *libaio*)
- `rw` - тип операции ввода-вывода (read - линейное чтение, write - линейная запись, randread - случайное чтение, randwrite - случайная запись, readwrite)
- `direct` - не использовать буферизацию
- `size` - размер файла
- `directory` - папка для тестов (необходимо сначала создать)

`stress` - это утилита для Linux, которая используется для *создания нагрузки* на систему с целью тестирования ее *стабильности* и *производительности*. Она позволяет *имитировать* высокую загрузку CPU, памяти, дисков и сети, чтобы проверить, как система будет вести себя в условиях *экстремальной* нагрузки.

```bash
# Тестиуем CPU (добавляем процессы)
stress -c 13
# Тестируем ввод/вывод
stress -i 4
# Тестируем оперативную память
stress -m 10
# Тестируем диск
stress -d 1 --hdd-bytes 3G
# Комбинируем разные опции и ставим таймаут
stress -c 20 -d 1 -t 60
```

`iperf3` - это утилита для тестирования *пропускной способности сети* в Linux. Она позволяет измерять *скорость передачи* данных между двумя узлами в сети, что полезно для оценки *производительности* сети, выявления узких мест и *оптимизации* настроек сетевого оборудования.

[[linux_diagnistics#linux|^ В начало]]
***
## Load Average в Linux

*В Linux средние нагрузки (Load Average)* - это "средние значения нагрузки на *систему*". Они измеряют количество *выполняемых* потоков и *ожидающих* своей очереди (процессор, диск, непрерываемые блокировки). Иными словами, эта метрика отражает количество потоков, которые *не простаивают полностью*. *Преимущество*: учитывается потребность в разных ресурсах.
*В других ОС средние нагрузки* - это "средние значения нагрузки на *процессор*". Они измеряют количество потоков, *выполняемых* и *готовых к выполнению* в процессоре. *Преимущество*: проще в понимании и обосновании (только для процессоров).

Это мера нагрузки, которая *может превышать* обрабатываемую системой в данный момент. Большинство инструментов показывает *три* средних значения: для 1, 5 и 15 минут. *Load average* измеряется в *безразмерных* единицах. Например, значение 1.00 означает полную загрузку *одного процессора*, а значение 2.00 - полную загрузку *двух процессоров*.

```bash
load avearage: 25.25, 23.40, 23.46
```

*Некоторые триггеры:*

- если значения *равны* 0.0, то система в состоянии простоя
- если среднее значение для 1 минуты *выше*, чем для 5 или 15, то нагрузка *растет*
- если среднее значение для 1 минуты *ниже*, чем для 5 или 15, то нагрузка *снижается*
- если значения нагрузки выше, чем количество процессоров, то могут быть проблемы с производительностью (в зависимости от ситуации)

[[linux_diagnistics#linux|^ В начало]]
***
## IOPS в Linux

*IOPS (Input/Output Operations Per Second)* – один из ключевых параметров при измерении *производительности* систем хранения данных, жестких дисков, твердотельных дисков и сетевых хранилищ данных. По сути, *IOPS* это *количество блоков*, которое успевает считаться или записаться на носитель.

Основными измеряемыми величинами являются операции *линейного* (последовательного) и *произвольного* (случайного) доступа.

Под *линейными* операциям чтения/записи, при которых части файлов считываются последовательно, одна за другой, подразумевается передача *больших* файлов (более 128 К). При *произвольных* операциях данные читаются случайно из разных областей носителя, обычно они ассоциируются с размером блока 4 Кбайт.

**Приблизительные значения IOPS для жестких дисков**

|        Устройство        | Тип |     IOPS      |   Интерфейс   |
| :----------------------: | :-: | :-----------: | :-----------: |
| 7,200 об/мин SATA-диски  | HDD | ~75-100 IOPS  | SATA 3 Гбит/с |
| 10,000 об/мин SATA-диски | HDD | ~125-150 IOPS | SATA 3 Гбит/с |
| 10,000 об/мин SAS-диски  | HDD |   ~140 IOPS   |      SAS      |
| 15,000 об/мин SAS-диски  | HDD | ~175-210 IOPS |      SAS      |

**Приблизительные значения IOPS для SSD**

|        Устройство        | Тип |                  IOPS                  |   Интерфейс   |
| :----------------------: | :-: | :------------------------------------: | :-----------: |
|    Intel X25-M G2 MLC    | SSD |              ~8 600 IOPS               | SATA 3 Гбит/с |
|       OCZ Vertex 3       | SSD | ~60 000 IOPS (Произвольная запись 4K)  | SATA 6 Гбит/с |
|    OCZ RevoDrive 3 X2    | SSD | ~200 000 IOPS (Произвольная запись 4K) |     PCIe      |
| OCZ Z-Drive R4 CloudServ | SSD |            ~1 400 000 IOPS             |     PCIe      |

[[linux_diagnistics#linux|^ В начало]]
***
## Базовые нагрузочные тесты

**1. Повышенная нагрузка на процессор**

*Использовалось:* `stress -c 50`

*Результаты:*

- Процессор большую часть процессорного времени проводит в пространстве пользователя.
- load average показывает паттерн растущей нагрузки (первое значение больше второго и третьего), пока не выровняется.
- Скорость чтения и записи упала приблизительно на 20%-30%.
- На оперативную память почти не влияет.
- Скорость передачи данных по сети почти не изменилась.

**2. Недостаток оперативной памяти**

*Использовалось:* понижение лимита оперативной памяти до 512мб в гипервизоре + `stress -m 5`

*Результаты:*

- При недостатке оперативной памяти подключается swap (если он есть).
- Процессор большую часть процессорного времени проводит в системном пространстве.
- Немного поднимается статистика по wa (операции ввода/вывода) в top.
- load average показывает паттерн растущей нагрузки (первое значение больше второго и третьего), пока не выровняется.
- Жесткий диск начинает работать почти на 100%.
- Скорость чтения и записи упала приблизительно на 50%-60%.
- Скорость передачи данных по сети упала приблизительно на 30%.

**3. Ограничение работы сети**

*Использовалось:* ограничение трафика до 128 Kbps

*Результаты:*

- При TCP соединении появляется разница между отправленными и полученными пакетами (полученных меньше).
- При TCP соединении появились пропуски (когда передалось 0.0), количество приблизительно 50/50.
- При UDP соединении отправленные пакеты не изменились, а вот полученные пакеты многократно снизались.

*Использовалось:* ограничение трафика до 128 Kbps и потеря пакетов 20%

*Результаты:*

- При TCP соединении появляется разница между отправленными и полученными пакетами (полученных меньше).
- При TCP соединении появились пропуски (когда передалось 0.0), количество приблизительно 9 пропусков на 1 успешную отправку.
- При TCP соединении появились повторные попытки отправки (retr).
- При UDP соединении отправленные пакеты не изменились, а вот полученные пакеты многократно снизались.

*Использовалось:* потеря пакетов 20%

*Результаты:*

- При TCP соединении появляется разница между отправленными и полученными пакетами (полученных меньше).
- При TCP соединении появились пропуски (когда передалось 0.0), количество приблизительно 9 пропусков на 1 успешную отправку.
- При TCP соединении появились повторные попытки отправки (retr).
- При UDP соединении показания почти такие же, как без ограничений, лишь на 20% снизился объем полученных пакетов.

*Вывод:* TCP соединение более чувствительно к уменьшению скорости и потере пакетов, т.к. оно является безопасным соединением и каждый раз будет ожидать подтверждения доставки пакета. UDP же посылает пакеты в сторону адресата, даже без проверки готов ли он их принять, поэтому в тестах в качестве отправителя его показания не изменяются.

**4. Ограничение жесткого диска (IOPS)**

*Использовалось:* ограничение чтения/записи с безлимитного до 10 IOPS

*Результаты:*

- Все операции линейной/случайной записи/чтения снизились до IOPS=10 (41.8KiB/S).
- Тесты без ограничений были на файле размером 100Мb, после ограничений пришлось использовать файл размером 1Mb, т.к. 100Mb обрабатывался бы 40 минут.
- В целом понижение производительности системы

[[linux_diagnistics#linux|^ В начало]]
***